package cron

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/zinrai/x-scheduler/internal/config"
	"github.com/zinrai/x-scheduler/pkg/logger"
)

const (
	CronFilePrefix = "# Generated by x-scheduler\n# Do not edit manually\n\n"
	CronDir        = "/etc/cron.d"
	CronFileName   = "x-scheduler"
	CommentMaxLen  = 50
)

// Handles cron configuration file generation
type Generator struct {
	executablePath string
	configPath     string
}

// Creates a new cron generator
func NewGenerator(executablePath, configPath string) *Generator {
	return &Generator{
		executablePath: executablePath,
		configPath:     configPath,
	}
}

// Creates cron configuration file from posts
func (g *Generator) Generate(posts []config.Post) error {
	cronFilePath := filepath.Join(CronDir, CronFileName)

	logger.Info("Generating cron file: %s", cronFilePath)

	content := CronFilePrefix

	for _, post := range posts {
		entry := g.createCronEntry(post)
		content += FormatCronEntry(entry) + "\n\n"
	}

	// Ensure directory exists
	if err := os.MkdirAll(CronDir, 0755); err != nil {
		return fmt.Errorf("failed to create cron directory: %w", err)
	}

	// Write file with appropriate permissions
	if err := os.WriteFile(cronFilePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cron file: %w", err)
	}

	logger.Info("Successfully generated cron configuration with %d entries", len(posts))
	return nil
}

// Creates a cron entry for a single post
func (g *Generator) createCronEntry(post config.Post) CronEntry {
	schedule := TimeToCron(post.ScheduledAt)
	command := fmt.Sprintf("%s -execute %s", g.executablePath, g.configPath)
	comment := fmt.Sprintf("%s - %s",
		post.ScheduledAt.Format("2006-01-02 15:04"),
		TruncateComment(post.Content, CommentMaxLen))

	return CronEntry{
		Schedule: schedule,
		Command:  command,
		Comment:  comment,
	}
}

// Removes the cron configuration file
func (g *Generator) Remove() error {
	cronFilePath := filepath.Join(CronDir, CronFileName)

	if _, err := os.Stat(cronFilePath); os.IsNotExist(err) {
		logger.Info("Cron file does not exist: %s", cronFilePath)
		return nil
	}

	if err := os.Remove(cronFilePath); err != nil {
		return fmt.Errorf("failed to remove cron file: %w", err)
	}

	logger.Info("Successfully removed cron configuration: %s", cronFilePath)
	return nil
}

// Checks if we can write to the cron directory
func (g *Generator) Validate() error {
	// Check if cron directory exists or can be created
	if err := os.MkdirAll(CronDir, 0755); err != nil {
		return fmt.Errorf("cannot access cron directory %s: %w", CronDir, err)
	}

	// Check if we can write to the directory
	testFile := filepath.Join(CronDir, ".x-scheduler-test")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		return fmt.Errorf("cannot write to cron directory %s: %w", CronDir, err)
	}

	// Clean up test file
	os.Remove(testFile)

	return nil
}

// Returns what the cron file would look like without writing it
func (g *Generator) Preview(posts []config.Post) string {
	content := CronFilePrefix

	for _, post := range posts {
		entry := g.createCronEntry(post)
		content += FormatCronEntry(entry) + "\n\n"
	}

	return strings.TrimSpace(content)
}
